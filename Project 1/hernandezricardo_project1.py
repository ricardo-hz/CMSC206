# -*- coding: utf-8 -*-
"""HernandezRicardo_Project1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19Clv3-XcTrDa9tkCoeyyz0W9oH9WNbU3
"""

#Author: Ricardo Hernandez
#Course: CMSC206
#Professor: Gary Thai
#Due Date: 9/25/2024

#For conversion to other number systems. Enter desired number system as first
#argument and decimal numbers as second.
def decToBase(desiredBase, baseTenNum):
  remainders = list()
  quotient = int()
  remainder = int()
  #This variable exists to create a readable output
  initialNumber = baseTenNum

  #Begin conversion process
  while baseTenNum // desiredBase != 0:
    #BUG: My algorithm ignores the last digit of the number to be converted
    #FIX: Repeat the algorithm a single time after while loop ends
    remainder = baseTenNum % desiredBase
    remainders.append(remainder)
    baseTenNum = baseTenNum // desiredBase
  #Handle the last digit
  remainder = baseTenNum % desiredBase
  remainders.append(remainder)
  baseTenNum = baseTenNum // desiredBase
  #Complete conversion by reversing remainders
  remainders.reverse()

  #NOTE: If a number system with a prefix is used besides binary, hex or octal,
  #the conversion will be slightly off
  #Octal numbers start with a leading 0
  if desiredBase == 8:
    output = "0"
  #Hex numbers begin with 0x
  elif desiredBase == 16:
    output = "0x"
  #Decimal numbers begin with 0b
  elif desiredBase == 2:
    output = "0b"
  #Any other number system (for now) starts with nothing as they have not been
  #implemented
  else:
    output = ""

  #Add array elements to final answer
  for remainder in remainders:
    #Handle Base 16
    if desiredBase == 16:
      #Handle Base 16, remainder 10
      if remainder == 10:
        output += ('A')
      #Handle Base 16, remainder 11
      elif remainder == 11:
        output += ('B')
      #Handle Base 16, remainder 12
      elif remainder == 12:
        output += ('C')
      #Handle Base 16, remainder 13
      elif remainder == 13:
        output += ('D')
      #Handle Base 16, remainder 14
      elif remainder == 14:
        output += ('E')
      #Handle Base 16, remainder 15
      elif remainder == 15:
        output += ('F')
      #Handle Base 16, non edge cases
      else:
        output += str(remainder)
    #Handle Bases 2 & 8
    else:
      output += str(remainder)

  #Return final answer
  return ("{} is equal to {} in base-{}".format(initialNumber, output, desiredBase))

#This function is responsible for converting decimal numbers to English
#A decimal number should be entered as its argument
def decToEnglish(baseTenNum):
  hundreds = 0
  tens = 0
  ones = 0
  englishRepresentation = ""
  #This variable is used to avoid having a number like 12 be output as "Twelve Zero"
  uniqueNumber = False
  #Segment baseTenNum into parts. Keep in mind that numbers like 12 are read
  #"Twelve" and not "Ten two"
  #If baseTenNum % 100 is between 11 and 19, do not assign anything to ones
  if baseTenNum % 100 >= 11 and baseTenNum % 100 <= 19:
    uniqueNumber = True
    tens = baseTenNum % 100
    baseTenNum -= tens
    hundreds = baseTenNum % 1000
    baseTenNum -= hundreds
  #else, it's safe to assume there's no number between 11 and 19 in the argument
  else:
    ones = baseTenNum % 10
    baseTenNum -= ones
    tens = baseTenNum % 100
    baseTenNum -= tens
    hundreds = baseTenNum % 1000
    baseTenNum -= hundreds
  #Begin adding English representations, starting with hundreds
  match(hundreds):
    case 100:
      englishRepresentation += "One Hundred "
    case 200:
      englishRepresentation += "Two Hundred "
    case 300:
      englishRepresentation += "Three Hundred "
    case 400:
      englishRepresentation += "Four Hundred "
    case 500:
      englishRepresentation += "Five Hundred "
    case 600:
      englishRepresentation += "Six Hundred "
    case 700:
      englishRepresentation += "Seven Hundred "
    case 800:
      englishRepresentation += "Eight Hundred "
    case 900:
      englishRepresentation += "Nine Hundred "
  #Next English representations, add tens
  match(tens):
    case 11:
      englishRepresentation += "Eleven "
    case 12:
      englishRepresentation += "Twelve "
    case 13:
      englishRepresentation += "Thirteen "
    case 14:
      englishRepresentation += "Fourteen "
    case 15:
      englishRepresentation += "Fifteen "
    case 16:
      englishRepresentation += "Sixteen "
    case 17:
      englishRepresentation += "Seventeen "
    case 18:
      englishRepresentation += "Eighteen "
    case 19:
      englishRepresentation += "Nineteen "
    case 20:
      englishRepresentation += "Twenty "
    case 30:
      englishRepresentation += "Thirty "
    case 40:
      englishRepresentation += "Forty "
    case 50:
      englishRepresentation += "Fifty "
    case 60:
      englishRepresentation += "Sixty "
    case 70:
      englishRepresentation += "Seventy "
    case 80:
      englishRepresentation += "Eighty "
    case 90:
      englishRepresentation += "Ninety "
  #Ones match should only happen if uniqueNumber = false to avoid a number
  #like 12 being read as "Twelve Zero"
  if uniqueNumber == False:
    match(ones):
      case 0:
        englishRepresentation += "Zero"
      case 1:
        englishRepresentation += "One"
      case 2:
        englishRepresentation += "Two"
      case 3:
        englishRepresentation += "Three"
      case 4:
        englishRepresentation += "Four"
      case 5:
        englishRepresentation += "Five"
      case 6:
        englishRepresentation += "Six"
      case 7:
        englishRepresentation += "Seven"
      case 8:
        englishRepresentation += "Eight"
      case 9:
        englishRepresentation += "Nine"
  #Remove any trailing spaces and return english representation
  #Lesson learned: the rstrip() method can remove trailing characters. Space is
  #the default character
  return(englishRepresentation.rstrip())

#This function is responsible for converting binary numbers to decimal (base-10)
#A binary number should be entered as its argument
def binaryToDec(binaryValue):
  binary = list(binaryValue)
  #Lesson learned: I expected Python to index strings with the last letter being
  #at the 0'th index. This isn't how it works.
  binary.reverse()
  binaryLength0Based = len(binary) - 1
  accum = 0
  #Loop through length of binary number, adding non zero values to accumulator
  while binaryLength0Based != -1:
      if binary[binaryLength0Based] == "1":
        #Binary can be translated to decimal using powers of 2
          accum += (2**binaryLength0Based)
      binaryLength0Based -= 1
  return ("{} is equivalent to {} in base-10".format(binaryValue, accum))

#This function is responsible for obtaining a binary number and validating that
#it's valid (only contains 0's and 1's)
def getBinaryNumber():
  print("Please enter a binary number. Note that binary numbers can only contain 1's and 0's (Do not begin your entry with 0b).")
  numberEntered = str(input())
  for digit in numberEntered:
    if digit != "1" and digit != "0":
        flag = False
        break
    else:
        flag = True
  while flag == False:
    print("Your entry was invalid. Try again")
    numberEntered = str(input())
    for digit in numberEntered:
      if digit != "1" and digit != "0":
          flag = False
          break
      else:
          flag = True
  return numberEntered

#This function is responsible for obtaining a base-10 number for the user and
#validating that the number isn't a string, is within the range 0-999, and is
#a whole number
def getBaseTenNumber():
  try:
    print("Please enter a whole number to convert in the range 0-999.")
    numberEntered = int((float(input())//1))
    numberEntered = int(numberEntered)
    while (not(numberEntered >= 0 and numberEntered <= 999)):
      print("The number you have entered is invalid. Please choose a number in the range 0-999.")
      numberEntered = float(input())//1
      numberEntered = int(numberEntered)
    return numberEntered
  except:
    print("ERROR: Non number entered. Returning 0.")
    return 0

#########MAIN METHOD##########
print("*** NUMBER CONVERTER ***")
#Used for program looping
cont = 'y'
userMenuChoice = str()
while((cont == 'y' or cont == 'Y') and (userMenuChoice != "x" and userMenuChoice != "X")):
  print("CHOOSE 1 - to convert from DECIMAL to HEXADECIMAL")
  print("CHOOSE 2 - to convert from DECIMAL to OCTAL")
  print("CHOOSE 3 - to convert from DECIMAL to BINARY")
  print("CHOOSE 4 - to convert from BINARY to DECIMAL")
  print("CHOOSE 5 - to convert from DECIMAL to ENGLISH WORDS")
  print("CHOOSE X - to quit")
  #Prompt user input
  userMenuChoice = input()
  #Validate user choice
  while(userMenuChoice != "1" and userMenuChoice != "2" and userMenuChoice != "3" and userMenuChoice != "4" and userMenuChoice != "5" and userMenuChoice != "X" and userMenuChoice != "x"):
    print("Invalid selection. Valid entries are integers 1-5 or X to exit")
    userMenuChoice = input()
  #Responsible for choosing which conversion to complete based on user input
  match(userMenuChoice):
    case "1":
      print(decToBase(16, getBaseTenNumber()))
    case "2":
      print(decToBase(8, getBaseTenNumber()))
    case "3":
      print(decToBase(2, getBaseTenNumber()))
    case "4":
      print(binaryToDec(getBinaryNumber()))
    case "5":
      print(decToEnglish(getBaseTenNumber()))
  #Only ask to continue if the user hasn't stated they'd like to quit
  if userMenuChoice != 'X' and userMenuChoice != 'x':
    print("Would you like to continue? y/n")
    cont = input()[0]
    #print blank line for readability
    print()